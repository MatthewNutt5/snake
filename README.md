# snake
Final project for ELEC 422 - Basic Snake game coded in Verilog and implemented in CMOS static logic.

## General Information

This is a basic version of the classic Snake game coded in Verilog, synthesized into gate-level logic, and implemented in a physical VLSI layout. The final chip requires a dual-phase clock, reset signal, and directional signals as inputs, and outputs control signals for display multiplexing on an eight-by-eight LED array. For the sake of concise simulations, only one cycle of multiplexing is used (i.e. eight clock cycles). Game updates occur after every multiplexing phase, so if this chip were to be fabricated and run on a multi-megahertz clock, it is imperative to first adjust the number of multiplexing cycles so that the game updates occur at a more reasonable rate.

Dual-phase clocking is used for system synchronization. Two clock signals, `clka` and `clkb`, are patterned such that one signal completes a rising and falling cycle while the other remains low, then vice versa. All flip-flops update on the falling edge of the clocks, but input registers are updated on the falling edge of `clka`, whereas output registers are updated on the falling edge of `clkb`. This way, timing discipline can be guaranteed between all the modules of the project.

This project uses the standard cell library from Oklahoma State University for the AMI 0.5μm process.

## Verilog Core Modules

### Controller Module

The Controller Module in `/snake/source/verilog/controller.v` manages the synchronization between modules for the game. It contains three sub-FSMs:

1) The game FSM, showing whether the game is ready/started/ended,
2) The direction FSM, keeping track of which direction the snake is moving, and
3) The execution FSM, synchronizing the phases of game updates and display multiplexing.

Inputs include global clock and restart signals, various signals from the other modules, and a one-hot direction signal.

Outputs include each sub-FSM's current state, signals to the other modules, and control signals for a multiplexed 8x8 LED display.

### Logic Datapath

The Logic Datapath in `/snake/source/verilog/logic.v` keeps track of game data, facilitates game updates, and produces signals for displaying the game board.

Inputs include global clock and restart signals, game state and direction signals from the controller module, and the current random number from the PRNG module.

Outputs include game update signals to the controller module, the current state of the game board expressed as an array of LEDs, and a signal to the PRNG for requesting a new random number.

### PRNG Datapath

The PRNG Datapath in `/snake/source/verilog/prng.v` manages an LFSR-based random number generator.

Inputs include global clock and restart signals, and the request signal from the logic module.

The sole output is the current random number.

### Top Module

The Top Module in `/snake/source/verilog/top.v` integrates the above modules into one complete unit. It distributes the global inputs to each module, and interlinks the internal signals between the modules.

Inputs include dual-phase clocks, a restart signal generated by a button, and a one-hot direction signal also provided by buttons.

Outputs include the multiplexed display signals and all internal signals between the modules. The latter is not necessary for the function of the game, but is used while debugging with testbenches.

## Verilog Testbenches

Verilog testbenches in `/snake/source/testbench/` are used to verify the functionality of each module. For any given module `mod`, the corresponding testbench is named `mod_tb.v` in this directory. Simulations are performed with these testbenches in Questa, both before and after the code is synthesized into standard cells by Design Compiler.

## Gate Synthesis

Design Compiler synthesizes completed Verilog modules into gate-level logic. DC targets the OSU AMI 0.5μm cell library and provides useful estimates about statistics like area and power required by the synthesized design. The module is also tested after synthesis to ensure that no functionality has been lost by transforming the Verilog code into gates and registers.

## Chip Layout

Once a module has been synthesized, Innovus generates a physical layout for the design according to the cells and connections specified by Design Compiler. The resulting `.gds` file is imported into Magic, where it can be saved as `.mag` files representing the hierarchical cell structure and extracted for simulations.

## Padframe Integration

Innovus only generates a layout for the core design; for fabrication and installation into a physical package, the core must be routed in a padframe that can be wired bonded to the package. A 64-pin padframe built from the bidirectional and power pads in the cell library is just large enough to fit the core, and routing to the pads is done manually in Magic using the wire tool.

## IRSIM Testbenches

After using extracting the layout for simulation, Magic converts the `.ext` files into a `.sim` file, for use with IRSIM. Testbench `.cmd` files in `/snake/source/testbench/` - designed to emulate the corresponding Verilog testbench - provide input patterns for IRSIM. A Python script is used to help convert the input sequences from a Verilog testbench to the IRSIM format.

## Repo Setup

### Directories/Symlinks

The `/snake/source` directory holds most of the actual "hard" files of the repo, whereas the other directories should hold "soft" symbolic links (symlinks) pointing to the source directory. This way, files can be automatically synchronized across multiple directories. For example, Verilog files are used by Questa for simulation, so the `/snake/source/verilog` directory holds the hard `.v` files while the `/snake/Questa` should contain symlinks pointing to those hard files.

Any important file generated by the design tools (e.g. the .vh files from Design Compiler, .gds from Innovus, etc.) should be left as hard files in their directory of origin, then linked where needed. For example, if `/snake/Innovus` holds the hard file `final.gds`, then `/snake/Irsim` should have a symlink to it.

Note that in previous commits, scripts and configs for the design tools were also stored in `/snake/source` and linked to. However, the linking would run those scripts in the hard file's directory, instead of the intended design tool directory, so those hard files now are kept in their corresponding directory.

### `.gitignore`

The `.gitignore` is set up as a whitelist - a file/file type must be added for Git to track it. The `.gitignore` should be set to only keep track of the hard files in `/snake/source`, hard files generated by the design tools, and the symlinks to them; other files like logs, reports, etc. should not be included in the repo. Note that Git treats symlinks according to the type of file they point to - whitelisting Verilog files will include both the hard files and symlinks to them. Also, the `.gitignore` is configured such that files without a suffix, i.e. the scripts that run Design Compiler and Innovus, should be in the format `run_*`, in order for Git to track them.
